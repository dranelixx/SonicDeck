---
phase: 01-test-coverage
plan: 02
type: execute
---

<objective>
Add frontend test coverage for hooks and utility functions.

Purpose: Establish test patterns for React hooks with Tauri API mocking, enabling confident UI changes in later phases.
Output: New test files for hooks with passing tests and maintained 5%+ coverage threshold.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/TESTING.md

**Issue:** #75 Add frontend component tests

**Current State:**
- 2 existing test files: hotkeyDisplay.test.ts, waveformQueue.test.ts
- Coverage threshold: 5% (CI enforced)
- Tauri API mocking established in src/test/setup.ts

**Files WITHOUT tests:**
- `hooks/useFileDrop.ts` - File drag & drop handling
- `hooks/useHotkeyMappings.ts` - Hotkey state management
- `hooks/useAudioPlayback.ts` - Complex audio playback (lower priority)

**Test patterns (reference):**
@src/utils/waveformQueue.test.ts
@src/test/setup.ts

**Constraints:**
- Follow existing test patterns (Vitest + Testing Library)
- Mock Tauri APIs (invoke, listen) as in setup.ts
- Tests must pass: `yarn test:run`
- Coverage must stay >= 5%: `yarn test:coverage`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add useFileDrop hook tests</name>
  <files>src/hooks/useFileDrop.test.ts</files>
  <action>
Create test file for useFileDrop hook with tests for:
- Initial state (isDragging = false)
- Audio file filtering (accepts .mp3, .wav, .ogg, .m4a, .flac)
- Non-audio file rejection (shows toast)
- Drag event handlers prevent default

Test pattern using @testing-library/react:
```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { renderHook, act } from "@testing-library/react";
import { listen } from "@tauri-apps/api/event";
import { useFileDrop } from "./useFileDrop";

vi.mock("@tauri-apps/api/event", () => ({
  listen: vi.fn(() => Promise.resolve(() => {})),
}));

describe("useFileDrop", () => {
  const mockShowToast = vi.fn();
  const mockOnFilesDropped = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("should initialize with isDragging false", () => {
    const { result } = renderHook(() =>
      useFileDrop({
        showToast: mockShowToast,
        onFilesDropped: mockOnFilesDropped
      })
    );
    expect(result.current.isDragging).toBe(false);
  });

  it("should setup event listeners on mount", () => {
    const { result } = renderHook(() =>
      useFileDrop({
        showToast: mockShowToast,
        onFilesDropped: mockOnFilesDropped
      })
    );

    act(() => {
      result.current.setupFileDropListeners();
    });

    expect(listen).toHaveBeenCalledWith("tauri://drag-drop", expect.any(Function));
    expect(listen).toHaveBeenCalledWith("tauri://drag", expect.any(Function));
    expect(listen).toHaveBeenCalledWith("tauri://drag-cancelled", expect.any(Function));
  });
});
```

Focus on testable behavior without complex Tauri event simulation.
  </action>
  <verify>yarn test:run src/hooks/useFileDrop.test.ts</verify>
  <done>useFileDrop has 4+ tests covering initial state and event setup</done>
</task>

<task type="auto">
  <name>Task 2: Add useHotkeyMappings hook tests</name>
  <files>src/hooks/useHotkeyMappings.test.ts</files>
  <action>
Create test file for useHotkeyMappings hook with tests for:
- Initial state (empty mappings)
- Loading hotkeys on mount via invoke
- refreshHotkeys function calls invoke
- Error handling when invoke fails

Test pattern:
```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { renderHook, waitFor } from "@testing-library/react";
import { invoke } from "@tauri-apps/api/core";
import { useHotkeyMappings } from "./useHotkeyMappings";

vi.mock("@tauri-apps/api/core", () => ({
  invoke: vi.fn(),
}));

describe("useHotkeyMappings", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("should initialize with empty mappings", () => {
    vi.mocked(invoke).mockResolvedValue({ mappings: {} });
    const { result } = renderHook(() => useHotkeyMappings());
    expect(result.current.hotkeyMappings).toEqual({ mappings: {} });
  });

  it("should load hotkeys on mount", async () => {
    const mockMappings = { mappings: { "Ctrl+1": "sound-1" } };
    vi.mocked(invoke).mockResolvedValue(mockMappings);

    const { result } = renderHook(() => useHotkeyMappings());

    await waitFor(() => {
      expect(invoke).toHaveBeenCalledWith("load_hotkeys");
    });
  });

  it("should refresh hotkeys when called", async () => {
    vi.mocked(invoke).mockResolvedValue({ mappings: {} });
    const { result } = renderHook(() => useHotkeyMappings());

    await result.current.refreshHotkeys();

    expect(invoke).toHaveBeenCalledWith("load_hotkeys");
  });

  it("should handle invoke errors gracefully", async () => {
    const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    vi.mocked(invoke).mockRejectedValue(new Error("Load failed"));

    renderHook(() => useHotkeyMappings());

    await waitFor(() => {
      expect(consoleSpy).toHaveBeenCalled();
    });

    consoleSpy.mockRestore();
  });
});
```
  </action>
  <verify>yarn test:run src/hooks/useHotkeyMappings.test.ts</verify>
  <done>useHotkeyMappings has 4+ tests covering state, loading, refresh, and error handling</done>
</task>

<task type="auto">
  <name>Task 3: Verify coverage and run full test suite</name>
  <files>src/</files>
  <action>
Run full test suite and verify coverage:

1. Run all tests: `yarn test:run`
2. Run coverage check: `yarn test:coverage`
3. Verify threshold >= 5% passes

If coverage issues:
- Check that new test files are discovered
- Verify mocks don't interfere with coverage collection
  </action>
  <verify>yarn test:coverage passes with threshold >= 5%</verify>
  <done>All tests pass, coverage >= 5%, no regressions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `yarn test:run` passes all tests (including new ones)
- [ ] `yarn test:coverage` passes with threshold >= 5%
- [ ] No TypeScript errors in test files
- [ ] New tests follow existing patterns (describe/it structure)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- useFileDrop.test.ts exists with 4+ passing tests
- useHotkeyMappings.test.ts exists with 4+ passing tests
- Coverage threshold maintained at 5%+
</success_criteria>

<output>
After completion, create `.planning/phases/01-test-coverage/01-02-SUMMARY.md`
</output>

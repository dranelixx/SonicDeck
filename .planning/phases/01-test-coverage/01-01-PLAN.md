---
phase: 01-test-coverage
plan: 01
type: execute
---

<objective>
Expand Rust unit test coverage for untested modules.

Purpose: Provide test foundation for audio subsystem modules that currently lack tests, enabling confident refactoring in later phases.
Output: New test modules in device.rs, decode.rs, error.rs with passing tests and maintained 45%+ coverage threshold.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/TESTING.md

**Issue:** #77 Improve Rust unit test coverage

**Current State:**
- 117 existing Rust tests across 9 modules
- Coverage threshold: 45% (CI enforced)
- Test patterns established in cache.rs, manager.rs, playback.rs

**Modules WITHOUT tests:**
- `audio/error.rs` - Error enum with Display/From traits
- `audio/decode.rs` - Audio decoding (only integration tests exist)
- `audio/device.rs` - Device enumeration (requires mocking cpal)

**Modules WITH tests (reference patterns):**
@src-tauri/src/audio/cache.rs
@src-tauri/src/persistence.rs

**Constraints:**
- Follow existing test patterns (inline `#[cfg(test)]` modules)
- Use Arrange/Act/Assert structure
- Tests must pass: `cargo test`
- Coverage must stay >= 45%: `cargo llvm-cov --fail-under-lines 45`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AudioError tests</name>
  <files>src-tauri/src/audio/error.rs</files>
  <action>
Add `#[cfg(test)]` module to error.rs with tests for:
- Display trait output for each error variant (verify error messages are readable)
- From<io::Error> conversion works correctly
- Into<String> conversion for Tauri command error handling

Test pattern from existing code:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_audio_error_display_file_open() {
        let err = AudioError::FileOpen(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            "test error"
        ));
        let msg = err.to_string();
        assert!(msg.contains("Failed to open audio file"));
    }
}
```

Cover all error variants: FileOpen, ProbeFormat, NoTracks, DecoderCreation, PacketRead, Decode, NoData, DeviceEnumeration, NoDevices, DeviceConfig, UnsupportedFormat, StreamBuild, StreamStart, InvalidDeviceId, DeviceNotFound.
  </action>
  <verify>cargo test audio::error::tests -- --nocapture</verify>
  <done>All 15 error variants have Display tests, From/Into conversions tested</done>
</task>

<task type="auto">
  <name>Task 2: Add decode.rs unit tests</name>
  <files>src-tauri/src/audio/decode.rs</files>
  <action>
Add `#[cfg(test)]` module to decode.rs with tests for:
- Error handling for non-existent files
- Error handling for invalid/corrupted audio files
- Successful decode using existing test fixtures (tests/fixtures/)

Use existing fixtures:
- test_mono.mp3 (1s, 44.1kHz, Mono)
- test_stereo.ogg (1s, 48kHz, Stereo)
- test_stereo.m4a (1s, 48kHz, Stereo)

Test pattern:
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    fn get_fixture_path(filename: &str) -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("tests")
            .join("fixtures")
            .join(filename)
    }

    #[test]
    fn test_decode_nonexistent_file() {
        let result = decode_audio_file("/nonexistent/path.mp3");
        assert!(result.is_err());
    }

    #[test]
    fn test_decode_mp3_fixture() {
        let path = get_fixture_path("test_mono.mp3");
        let result = decode_audio_file(path.to_str().unwrap());
        assert!(result.is_ok());
        let audio = result.unwrap();
        assert!(audio.samples.len() > 0);
        assert_eq!(audio.sample_rate, 44100);
        assert_eq!(audio.channels, 1);
    }
}
```

Test all three formats (MP3, OGG, M4A) and verify sample_rate, channels, and non-empty samples.
  </action>
  <verify>cargo test audio::decode::tests -- --nocapture</verify>
  <done>Decode tests for all 3 formats pass, error cases covered</done>
</task>

<task type="auto">
  <name>Task 3: Verify coverage threshold</name>
  <files>src-tauri/</files>
  <action>
Run full test suite and verify coverage threshold:

1. Run all tests: `cargo test`
2. Run coverage check: `cargo llvm-cov --fail-under-lines 45`
3. If coverage dropped, identify gaps and add targeted tests

Note: device.rs tests are challenging due to cpal hardware dependency - skip if mocking is complex. Focus on error.rs and decode.rs which provide more testable pure functions.
  </action>
  <verify>cargo llvm-cov --fail-under-lines 45 passes</verify>
  <done>All tests pass, coverage >= 45%, no regressions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo test` passes all tests (including new ones)
- [ ] `cargo llvm-cov --fail-under-lines 45` passes
- [ ] No compiler warnings in test code
- [ ] New tests follow existing patterns (Arrange/Act/Assert)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- AudioError has Display tests for all 15 variants
- decode.rs has unit tests for MP3, OGG, M4A fixtures
- Coverage threshold maintained at 45%+
</success_criteria>

<output>
After completion, create `.planning/phases/01-test-coverage/01-01-SUMMARY.md`
</output>

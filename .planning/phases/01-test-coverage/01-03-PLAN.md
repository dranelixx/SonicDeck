---
phase: 01-test-coverage
plan: 03
type: execute
---

<objective>
Add tests for core audio playback hook to enable precise error diagnosis.

Purpose: When audio playback fails, tests pinpoint exactly WHERE the failure occurs (invoke parameters, state transitions, error handling) rather than just "it doesn't work".
Output: Comprehensive useAudioPlayback tests covering invoke calls, state management, and error paths.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/TESTING.md

**Continuation of:** Issue #75 Add frontend component tests

**Why this matters:**
Manual testing tells you "sound doesn't play". These tests tell you:
- "invoke was called with wrong deviceId format"
- "error from backend wasn't caught"
- "playingSoundIds state didn't update"
- "cleanup function didn't unsubscribe listener"

**Target file:**
@src/hooks/useAudioPlayback.ts

**Test patterns (reference):**
@src/utils/waveformQueue.test.ts
@src/hooks/useFileDrop.test.ts (created in Plan 02)

**Key behaviors to test:**
1. playSound calls invoke with correct parameters
2. Error handling shows toast on failure
3. State updates (playingSoundIds Set)
4. Device validation (shows toast if not configured)
5. Event listener setup/cleanup
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test playSound invoke parameters</name>
  <files>src/hooks/useAudioPlayback.test.ts</files>
  <action>
Create test file with tests that verify invoke is called correctly:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { renderHook, act, waitFor } from "@testing-library/react";
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";
import { useAudioPlayback } from "./useAudioPlayback";

vi.mock("@tauri-apps/api/core", () => ({
  invoke: vi.fn(),
}));

vi.mock("@tauri-apps/api/event", () => ({
  listen: vi.fn(() => Promise.resolve(() => {})),
}));

describe("useAudioPlayback", () => {
  const mockShowToast = vi.fn();
  const mockSound = {
    id: "sound-1",
    name: "Test Sound",
    file_path: "/path/to/sound.mp3",
    category_id: "cat-1",
    icon: null,
    volume: 0.8,
    is_favorite: false,
    trim_start_ms: 100,
    trim_end_ms: 5000,
  };

  const defaultProps = {
    device1: "device:0",
    device2: "device:1",
    volume: 1.0,
    showToast: mockShowToast,
    soundLibrary: { sounds: [mockSound] },
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("playSound invoke parameters", () => {
    it("should call invoke with correct command name", async () => {
      vi.mocked(invoke).mockResolvedValue({
        playback_id: "pb-1",
        action: "started",
        stopped_playback_id: null
      });

      const { result } = renderHook(() => useAudioPlayback(defaultProps));

      await act(async () => {
        await result.current.playSound(mockSound);
      });

      expect(invoke).toHaveBeenCalledWith(
        "play_dual_output",
        expect.any(Object)
      );
    });

    it("should pass file_path as filePath", async () => {
      vi.mocked(invoke).mockResolvedValue({
        playback_id: "pb-1",
        action: "started",
        stopped_playback_id: null
      });

      const { result } = renderHook(() => useAudioPlayback(defaultProps));

      await act(async () => {
        await result.current.playSound(mockSound);
      });

      expect(invoke).toHaveBeenCalledWith(
        "play_dual_output",
        expect.objectContaining({
          filePath: "/path/to/sound.mp3",
        })
      );
    });

    it("should pass device IDs correctly", async () => {
      vi.mocked(invoke).mockResolvedValue({
        playback_id: "pb-1",
        action: "started",
        stopped_playback_id: null
      });

      const { result } = renderHook(() => useAudioPlayback(defaultProps));

      await act(async () => {
        await result.current.playSound(mockSound);
      });

      expect(invoke).toHaveBeenCalledWith(
        "play_dual_output",
        expect.objectContaining({
          deviceId1: "device:0",
          deviceId2: "device:1",
        })
      );
    });

    it("should use sound-specific volume over global volume", async () => {
      vi.mocked(invoke).mockResolvedValue({
        playback_id: "pb-1",
        action: "started",
        stopped_playback_id: null
      });

      const { result } = renderHook(() => useAudioPlayback(defaultProps));

      await act(async () => {
        await result.current.playSound(mockSound); // mockSound.volume = 0.8
      });

      expect(invoke).toHaveBeenCalledWith(
        "play_dual_output",
        expect.objectContaining({
          volume: 0.8, // Sound's volume, not global 1.0
        })
      );
    });

    it("should pass trim parameters", async () => {
      vi.mocked(invoke).mockResolvedValue({
        playback_id: "pb-1",
        action: "started",
        stopped_playback_id: null
      });

      const { result } = renderHook(() => useAudioPlayback(defaultProps));

      await act(async () => {
        await result.current.playSound(mockSound);
      });

      expect(invoke).toHaveBeenCalledWith(
        "play_dual_output",
        expect.objectContaining({
          trimStartMs: 100,
          trimEndMs: 5000,
        })
      );
    });
  });
});
```

These tests ensure the contract between frontend and backend is correct.
  </action>
  <verify>yarn test:run src/hooks/useAudioPlayback.test.ts</verify>
  <done>5 tests verify invoke is called with correct parameters</done>
</task>

<task type="auto">
  <name>Task 2: Test error handling and validation</name>
  <files>src/hooks/useAudioPlayback.test.ts</files>
  <action>
Add tests for error paths and validation:

```typescript
describe("device validation", () => {
  it("should show toast when device1 is not configured", async () => {
    const propsWithoutDevice = {
      ...defaultProps,
      device1: "", // Empty device
    };

    const { result } = renderHook(() => useAudioPlayback(propsWithoutDevice));

    await act(async () => {
      await result.current.playSound(mockSound);
    });

    expect(mockShowToast).toHaveBeenCalledWith(
      "Please configure audio devices in Settings first"
    );
    expect(invoke).not.toHaveBeenCalled();
  });

  it("should show toast when device2 is not configured", async () => {
    const propsWithoutDevice = {
      ...defaultProps,
      device2: "", // Empty device
    };

    const { result } = renderHook(() => useAudioPlayback(propsWithoutDevice));

    await act(async () => {
      await result.current.playSound(mockSound);
    });

    expect(mockShowToast).toHaveBeenCalledWith(
      "Please configure audio devices in Settings first"
    );
    expect(invoke).not.toHaveBeenCalled();
  });
});

describe("error handling", () => {
  it("should handle invoke rejection gracefully", async () => {
    const consoleSpy = vi.spyOn(console, "error").mockImplementation(() => {});
    vi.mocked(invoke).mockRejectedValue(new Error("Playback failed"));

    const { result } = renderHook(() => useAudioPlayback(defaultProps));

    await act(async () => {
      await result.current.playSound(mockSound);
    });

    // Should not throw, should handle error internally
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });
});
```

These tests verify the app doesn't crash on errors and gives user feedback.
  </action>
  <verify>yarn test:run src/hooks/useAudioPlayback.test.ts</verify>
  <done>3 tests verify device validation and error handling</done>
</task>

<task type="auto">
  <name>Task 3: Test state management and run full suite</name>
  <files>src/hooks/useAudioPlayback.test.ts</files>
  <action>
Add tests for state management and verify full suite:

```typescript
describe("state management", () => {
  it("should initialize with empty playingSoundIds", () => {
    const { result } = renderHook(() => useAudioPlayback(defaultProps));

    // playingSoundIds is internal, but we can verify no sounds are "playing"
    expect(result.current.activeWaveform).toBeNull();
  });

  it("should initialize with no active waveform", () => {
    const { result } = renderHook(() => useAudioPlayback(defaultProps));

    expect(result.current.activeWaveform).toBeNull();
    expect(result.current.isWaveformExiting).toBe(false);
  });
});

describe("stopSound", () => {
  it("should call stop_sound invoke command", async () => {
    vi.mocked(invoke).mockResolvedValue(undefined);

    const { result } = renderHook(() => useAudioPlayback(defaultProps));

    await act(async () => {
      await result.current.stopSound("sound-1");
    });

    expect(invoke).toHaveBeenCalledWith("stop_sound", { soundId: "sound-1" });
  });
});

describe("stopAllSounds", () => {
  it("should call stop_all_sounds invoke command", async () => {
    vi.mocked(invoke).mockResolvedValue(undefined);

    const { result } = renderHook(() => useAudioPlayback(defaultProps));

    await act(async () => {
      await result.current.stopAllSounds();
    });

    expect(invoke).toHaveBeenCalledWith("stop_all_sounds");
  });
});
```

Then run full test suite:
1. `yarn test:run` - All tests pass
2. `yarn test:coverage` - Coverage >= 5%
  </action>
  <verify>yarn test:run && yarn test:coverage</verify>
  <done>useAudioPlayback.test.ts has 12+ tests, full suite passes, coverage maintained</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `yarn test:run` passes all tests
- [ ] `yarn test:coverage` passes with threshold >= 5%
- [ ] useAudioPlayback.test.ts covers: invoke params, validation, errors, state, stop functions
- [ ] Tests provide diagnostic value (clear names, specific assertions)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- useAudioPlayback.test.ts exists with 12+ passing tests
- When a test fails, the test name tells you exactly what broke
- Coverage threshold maintained at 5%+
</success_criteria>

<output>
After completion, create `.planning/phases/01-test-coverage/01-03-SUMMARY.md`

This completes Phase 1: Test Coverage. Mark phase as complete in ROADMAP.md.
</output>

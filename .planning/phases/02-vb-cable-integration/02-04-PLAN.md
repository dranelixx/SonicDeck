---
phase: 02-vb-cable-integration
plan: 04
type: execute
---

<objective>
Implement microphone routing ("Abhören") so users can be heard on Discord while using VB-Cable for sounds.

Purpose: Complete the Discord integration - friends hear both sounds AND the user's voice.
Output: Microphone selection UI, Windows "Listen to this device" automation, enable/disable toggle.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-vb-cable-integration/02-RESEARCH.md
@.planning/phases/02-vb-cable-integration/02-CONTEXT.md
@.planning/phases/02-vb-cable-integration/02-01-SUMMARY.md
@.planning/phases/02-vb-cable-integration/02-02-SUMMARY.md
@.planning/phases/02-vb-cable-integration/02-03-SUMMARY.md

**Relevant source files:**
@src/components/settings/VbCableSettings.tsx
@src-tauri/src/vbcable/mod.rs
@src-tauri/src/commands/vbcable.rs
@src-tauri/src/audio/device.rs

**The Problem:**
When using VB-Cable with Discord:
- Discord Input = CABLE Output → Friends hear sounds ✓
- User's microphone is NOT routed → Friends don't hear the user ✗

**The Solution (Windows "Abhören" / "Listen to this device"):**
1. mmsys.cpl → Recording → User's Microphone → Properties
2. Tab "Listen" → ✓ "Listen to this device"
3. Playback through: CABLE Input

Audio flow: Microphone → CABLE Input → CABLE Output → Discord

**Technical approach:**
Windows "Listen to this device" can be controlled via:
- Registry: HKCU\Software\Microsoft\Multimedia\Audio\DeviceCacheXXX (complex, undocumented)
- Core Audio API: Not directly supported
- PolicyConfig: May work with some workarounds

Alternative approach:
- Use Windows audio loopback with wasapi or cpal
- Create our own audio routing in Rust

Research needed before implementation to determine best approach.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Research Windows "Listen to this device" automation</name>
  <files>None (research only)</files>
  <action>
Research the best approach to programmatically enable "Listen to this device":

1. **Registry approach**: Check if DeviceCache registry keys can be modified
2. **COM/PolicyConfig**: Check if IPolicyConfig or similar can control this
3. **Own audio routing**: Evaluate using cpal/wasapi to capture mic and route to CABLE Input

Document findings and decide on implementation approach.

Key questions to answer:
- Can we enable "Listen to this device" programmatically?
- Do we need admin rights?
- How do we undo it when user disables the feature?
- Is there a simpler alternative (own audio routing)?
  </action>
  <verify>Research documented, approach decided</verify>
  <done>Implementation approach determined</done>
</task>

<task type="auto">
  <name>Task 2: Enumerate capture devices (microphones)</name>
  <files>src-tauri/src/vbcable/mod.rs, src-tauri/src/commands/vbcable.rs, src-tauri/src/lib.rs</files>
  <action>
Add function to list available capture (input) devices for microphone selection.

**vbcable/mod.rs** or new file **vbcable/microphone.rs**:
```rust
use cpal::traits::{DeviceTrait, HostTrait};

/// List available capture devices (microphones)
pub fn list_capture_devices() -> Vec<(String, String)> {
    let host = cpal::default_host();
    let mut devices = Vec::new();

    if let Ok(input_devices) = host.input_devices() {
        for device in input_devices {
            if let Ok(name) = device.name() {
                // Skip VB-Cable devices
                if !name.to_lowercase().contains("cable") {
                    let id = format_device_id(&device); // reuse from audio module
                    devices.push((id, name));
                }
            }
        }
    }

    devices
}
```

**commands/vbcable.rs** - Add command:
```rust
#[tauri::command]
pub fn list_microphones() -> Vec<(String, String)> {
    list_capture_devices()
}
```

Register in lib.rs.
  </action>
  <verify>cargo check compiles, command returns list of microphones</verify>
  <done>Microphone enumeration working</done>
</task>

<task type="auto">
  <name>Task 3: Implement microphone routing (based on research)</name>
  <files>src-tauri/src/vbcable/microphone.rs, src-tauri/src/commands/vbcable.rs</files>
  <action>
Implement the routing based on Task 1 research findings.

**Option A: Registry manipulation**
- Modify Windows registry to enable "Listen to this device"
- Set playback device to CABLE Input
- Store original settings for undo

**Option B: Own audio routing with cpal**
- Capture audio from selected microphone
- Route to CABLE Input device
- Run in background thread
- Stop when disabled

Commands to implement:
```rust
#[tauri::command]
pub fn enable_microphone_routing(microphone_id: String) -> Result<(), String> {
    // Enable routing from microphone to CABLE Input
}

#[tauri::command]
pub fn disable_microphone_routing() -> Result<(), String> {
    // Disable routing, restore original state
}

#[tauri::command]
pub fn get_microphone_routing_status() -> Option<String> {
    // Returns microphone ID if routing is active, None otherwise
}
```
  </action>
  <verify>Microphone audio routes to CABLE Input when enabled</verify>
  <done>Microphone routing implemented</done>
</task>

<task type="auto">
  <name>Task 4: Add microphone routing UI to VbCableSettings</name>
  <files>src/components/settings/VbCableSettings.tsx</files>
  <action>
Add microphone routing section to VbCableSettings (only visible when VB-Cable is installed):

```tsx
{status?.status === "installed" && (
  <div className="mt-4 pt-4 border-t border-discord-darker">
    <h4 className="text-sm font-medium text-discord-text mb-2">
      Mikrofon-Routing (für Discord)
    </h4>
    <p className="text-xs text-discord-text-muted mb-3">
      Aktiviere dies, damit deine Freunde dich UND die Sounds hören können.
    </p>

    <div className="flex items-center gap-3">
      <select
        value={selectedMicrophone}
        onChange={(e) => setSelectedMicrophone(e.target.value)}
        disabled={isRoutingActive}
        className="flex-1 bg-discord-darker text-discord-text rounded px-3 py-2"
      >
        <option value="">Mikrofon auswählen...</option>
        {microphones.map(([id, name]) => (
          <option key={id} value={id}>{name}</option>
        ))}
      </select>

      <button
        onClick={isRoutingActive ? handleDisableRouting : handleEnableRouting}
        disabled={!selectedMicrophone && !isRoutingActive}
        className={`px-4 py-2 rounded font-medium ${
          isRoutingActive
            ? "bg-discord-danger hover:bg-discord-danger/80"
            : "bg-discord-primary hover:bg-discord-primary-hover"
        }`}
      >
        {isRoutingActive ? "Deaktivieren" : "Aktivieren"}
      </button>
    </div>
  </div>
)}
```

Add state and handlers:
- `microphones`: List from `list_microphones` command
- `selectedMicrophone`: Currently selected microphone ID
- `isRoutingActive`: Whether routing is currently enabled
- Load microphones on mount, check routing status
  </action>
  <verify>yarn typecheck passes, microphone routing UI visible and functional</verify>
  <done>Microphone routing UI complete</done>
</task>

<task type="auto">
  <name>Task 5: Persist microphone routing settings</name>
  <files>src-tauri/src/settings.rs, src/types.ts</files>
  <action>
Add microphone routing settings to AppSettings:

**settings.rs**:
```rust
pub struct AppSettings {
    // ... existing fields ...
    pub microphone_routing_device_id: Option<String>,
    pub microphone_routing_enabled: bool,
}
```

**types.ts**:
```typescript
export interface AppSettings {
  // ... existing fields ...
  microphone_routing_device_id: string | null;
  microphone_routing_enabled: boolean;
}
```

On app startup, if `microphone_routing_enabled` is true, automatically enable routing.
  </action>
  <verify>Settings persist across app restarts</verify>
  <done>Microphone routing settings persisted</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Microphone routing for Discord integration</what-built>
  <how-to-verify>
    1. Run: yarn tauri dev
    2. Open Settings
    3. VB-Cable should be installed (from previous tests)
    4. Look for "Mikrofon-Routing" section:
       - Select your microphone from dropdown
       - Click "Aktivieren"
    5. Open Discord:
       - Set Input Device to "CABLE Output"
       - Join a voice channel or start a call
    6. Verify:
       - Friends hear SonicDeck sounds ✓
       - Friends hear your voice ✓
    7. Disable routing:
       - Click "Deaktivieren" in SonicDeck
       - Verify microphone no longer routes through VB-Cable
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo check --manifest-path src-tauri/Cargo.toml` succeeds
- [ ] `yarn typecheck` passes
- [ ] `yarn lint` passes
- [ ] Microphone list populates correctly
- [ ] Routing can be enabled/disabled
- [ ] Audio actually routes (test with Discord)
- [ ] Settings persist across restarts
- [ ] Human verified end-to-end flow
</verification>

<success_criteria>
- Users can select their microphone
- Microphone audio routes through VB-Cable to Discord
- Friends hear both sounds AND the user's voice
- Routing can be toggled on/off
- Settings persist
</success_criteria>

<output>
After completion, create `.planning/phases/02-vb-cable-integration/02-04-SUMMARY.md`
</output>

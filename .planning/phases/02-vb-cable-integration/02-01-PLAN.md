---
phase: 02-vb-cable-integration
plan: 01
type: execute
---

<objective>
Build VB-Cable detection and Windows default audio device management infrastructure.

Purpose: Establish the backend foundation for VB-Cable integration - detection via cpal and default device save/restore via com-policy-config.
Output: New `vbcable/` module with detection, default device manager, and Tauri commands.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-vb-cable-integration/02-RESEARCH.md
@.planning/phases/02-vb-cable-integration/02-CONTEXT.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STACK.md

**Relevant source files:**
@src-tauri/src/audio/device.rs
@src-tauri/src/audio/mod.rs
@src-tauri/src/commands/audio.rs
@src-tauri/Cargo.toml

**Research findings to apply:**
- Use cpal device enumeration (already in use) - look for "CABLE Input" substring
- Use `com-policy-config` crate (v0.6.0) for default device save/restore
- Use `windows` crate for COM initialization (required by com-policy-config)
- VB-Cable appears as "CABLE Input (VB-Audio Virtual Cable)" for output

**Don't hand-roll:**
- Audio device enumeration → use cpal (already using)
- Set default audio device → use com-policy-config crate
- Registry access → not needed, use cpal device name matching

**Pitfalls to avoid:**
- Default device changes after VB-Cable install → we're addressing this
- Device enumeration timing → retry logic needed (not this plan, Plan 3)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create feature branch for VB-Cable integration</name>
  <files>git</files>
  <action>
Create a new feature branch from develop for this entire feature:

```bash
git checkout develop
git pull origin develop
git checkout -b feature/vb-cable-integration
```

This branch will contain all VB-Cable integration work (Plans 01, 02, 03).
After all plans complete, create PR to develop.
  </action>
  <verify>git branch shows feature/vb-cable-integration as current branch</verify>
  <done>Feature branch created and checked out</done>
</task>

<task type="auto">
  <name>Task 2: Add com-policy-config and windows dependencies</name>
  <files>src-tauri/Cargo.toml</files>
  <action>
Add the following dependencies for VB-Cable integration:

```toml
# VB-Cable integration dependencies
com-policy-config = "0.6"

[dependencies.windows]
version = "0.61"
features = [
    "Win32_Foundation",
    "Win32_Media_Audio",
    "Win32_System_Com",
]
```

Note: We need `windows` crate for COM initialization required by com-policy-config.
Do NOT add features like `Win32_Devices_FunctionDiscovery` or `Win32_UI_Shell_PropertiesSystem` - they're not needed for our use case.
  </action>
  <verify>cargo check --manifest-path src-tauri/Cargo.toml compiles without errors</verify>
  <done>Dependencies added, cargo check passes</done>
</task>

<task type="auto">
  <name>Task 3: Create vbcable module with detection and default device manager</name>
  <files>src-tauri/src/vbcable/mod.rs, src-tauri/src/vbcable/detection.rs, src-tauri/src/vbcable/default_device.rs</files>
  <action>
Create a new `vbcable/` module directory with three files:

**mod.rs** - Module exports:
```rust
//! VB-Cable integration module
//!
//! Provides VB-Cable detection and Windows default audio device management.

mod default_device;
mod detection;

pub use default_device::DefaultDeviceManager;
pub use detection::{detect_vb_cable, is_vb_cable_installed, VbCableInfo, VbCableStatus};
```

**detection.rs** - VB-Cable detection via cpal:
- `VbCableInfo` struct with `output_device` and `input_device` names
- `VbCableStatus` enum: `Installed { info: VbCableInfo }`, `NotInstalled`
- `is_vb_cable_installed() -> bool` - quick check
- `detect_vb_cable() -> Option<VbCableInfo>` - full detection with both devices
- Use cpal device enumeration, look for "cable input" (case-insensitive) in output devices
- Look for "cable output" in input devices (for completeness)
- Use `tracing::debug!` for logging detection results

**default_device.rs** - Windows default audio device save/restore:
- `DefaultDeviceManager` struct with `saved_device_id: Option<String>`
- `save_current_default() -> Result<Self, String>` - save current default output device
- `restore_default(&self) -> Result<(), String>` - restore saved device
- Use com-policy-config + windows crate for COM
- Handle COM initialization properly (CoInitializeEx/CoUninitialize)
- Use `eRender` and `eConsole` for output device role
- Return user-friendly error messages (not raw COM errors)

Pattern from RESEARCH.md:
```rust
use com_policy_config::IPolicyConfig;
use windows::Win32::Media::Audio::{eConsole, eRender, IMMDeviceEnumerator, MMDeviceEnumerator};
use windows::Win32::System::Com::{CoCreateInstance, CoInitializeEx, CoUninitialize, CLSCTX_ALL, COINIT_MULTITHREADED};
```

Important: Wrap all COM operations in `unsafe` blocks. Handle errors gracefully - if COM fails, return error string but don't panic.
  </action>
  <verify>cargo check --manifest-path src-tauri/Cargo.toml compiles, cargo test --manifest-path src-tauri/Cargo.toml passes</verify>
  <done>vbcable module created with detection.rs and default_device.rs, compiles without errors</done>
</task>

<task type="auto">
  <name>Task 4: Register vbcable module and add Tauri commands</name>
  <files>src-tauri/src/lib.rs, src-tauri/src/commands/mod.rs, src-tauri/src/commands/vbcable.rs</files>
  <action>
**lib.rs** - Add module declaration:
```rust
mod vbcable;
```

**commands/vbcable.rs** - Create new command file:
```rust
//! VB-Cable related Tauri commands

use tauri::State;
use crate::vbcable::{detect_vb_cable, is_vb_cable_installed, DefaultDeviceManager, VbCableStatus};

/// Check if VB-Cable is installed
#[tauri::command]
pub fn check_vb_cable_status() -> VbCableStatus {
    if let Some(info) = detect_vb_cable() {
        VbCableStatus::Installed { info }
    } else {
        VbCableStatus::NotInstalled
    }
}

/// Get the VB-Cable device name if installed
#[tauri::command]
pub fn get_vb_cable_device_name() -> Option<String> {
    detect_vb_cable().map(|info| info.output_device)
}

/// Save the current default audio device (call before VB-Cable install)
/// Returns the saved device ID on success
#[tauri::command]
pub fn save_default_audio_device() -> Result<String, String> {
    let manager = DefaultDeviceManager::save_current_default()?;
    // Store in app state or return the ID for frontend to track
    manager.get_saved_device_id().ok_or_else(|| "No device saved".to_string())
}

/// Restore a previously saved default audio device
#[tauri::command]
pub fn restore_default_audio_device(device_id: String) -> Result<(), String> {
    DefaultDeviceManager::restore_device(&device_id)
}
```

Add getter method to DefaultDeviceManager:
```rust
pub fn get_saved_device_id(&self) -> Option<String> {
    self.saved_device_id.clone()
}

pub fn restore_device(device_id: &str) -> Result<(), String> {
    // Static method for restoring without instance
}
```

**commands/mod.rs** - Export new module:
```rust
pub mod vbcable;
pub use vbcable::*;
```

**lib.rs** - Register commands in invoke_handler:
Add `check_vb_cable_status`, `get_vb_cable_device_name`, `save_default_audio_device`, `restore_default_audio_device` to the generate_handler! macro.
  </action>
  <verify>cargo check --manifest-path src-tauri/Cargo.toml compiles, yarn tauri dev starts without errors</verify>
  <done>Commands registered, app starts, commands callable from frontend (verified via console)</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo check --manifest-path src-tauri/Cargo.toml` succeeds
- [ ] `cargo test --manifest-path src-tauri/Cargo.toml` passes
- [ ] `yarn typecheck` passes
- [ ] `yarn tauri dev` starts without errors
- [ ] VB-Cable detection works (if VB-Cable installed on dev machine)
- [ ] Default device save/restore compiles (full test in Plan 3)
</verification>

<success_criteria>
- All tasks completed
- New vbcable/ module exists with detection.rs and default_device.rs
- Tauri commands registered and callable
- No TypeScript or Rust compilation errors
- App starts and runs normally
</success_criteria>

<output>
After completion, create `.planning/phases/02-vb-cable-integration/02-01-SUMMARY.md`
</output>
